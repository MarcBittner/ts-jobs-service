/Users/phaedrus/gits/ts-jobs-service/src/
├── config
├── config.ts
├── controllers
│   └── SearchController.ts
├── db.ts
├── index.ts
├── models
│   ├── SearchDefinition.ts
│   └── SearchResult.ts
├── routes
│   └── SearchRoutes.ts
├── server.ts
├── services
│   ├── LinkedInService.ts
│   └── SearchManager.ts
├── types.ts
└── utils
    └── logger.ts

7 directories, 12 files
// ./utils/logger.ts


import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: process.env.LOG_FILE_PATH || 'app.log' }),
  ],
});

export default logger;

// ./models/SearchResult.ts

import { Model, DataTypes } from 'sequelize';
import sequelize from '../db'; // Import your Sequelize instance

class SearchResult extends Model {
  public id!: number;
  public searchId!: number;
  public position!: string;
  public company!: string;
  public location!: string;
  public date!: string;
  public salary!: string;
  public jobUrl!: string;
}

SearchResult.init(
  {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    searchId: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    position: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    company: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    location: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    date: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    salary: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    jobUrl: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    sequelize,
    modelName: 'SearchResult',
  }
);

export default SearchResult;

// ./models/SearchDefinition.ts

import { Model, DataTypes } from 'sequelize';
import sequelize from '../db'; // Import your Sequelize instance

class SearchDefinition extends Model {
  public id!: number;
  public keyword!: string;
  public location!: string;
  public refreshInterval!: number;
}

SearchDefinition.init(
  {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    keyword: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    location: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    refreshInterval: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
  },
  {
    sequelize,
    modelName: 'SearchDefinition',
  }
);

export default SearchDefinition;

// ./types.ts

export interface JobListing {
  position: string;
  company: string;
  location: string;
  date: string;
  salary: string;
  jobUrl: string;
}

export interface QueryParams {
  keyword?: string;
  location?: string;
}

// ./index.ts

// ./index.ts

import express from 'express';
import * as dotenv from 'dotenv';
import { createSearch, getAllSearches, updateSearch, deleteSearch } from './controllers/searchController';
import { startMonitoringAllSearches } from './services/SearchManager';
import logger from './utils/logger';

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(express.json());

// Routes
app.post('/search', createSearch);
app.get('/search', getAllSearches);
app.put('/search/:id', updateSearch);
app.delete('/search/:id', deleteSearch);

// Start the server
app.listen(port, async () => {
  logger.info(`Server running on port ${port}`);
  await startMonitoringAllSearches();
});

// ./config.ts

import dotenv from 'dotenv';
dotenv.config();

export const dbConfig = {
  username: process.env.DB_USERNAME || 'postgres',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'job_service',
  host: process.env.DB_HOST || 'localhost',
  dialect: 'postgres',
};

// ./controllers/SearchController.ts

// ./controllers/SearchController.ts

import { Request, Response } from 'express';
import SearchDefinition from '../models/SearchDefinition';
import { scheduleJob } from '../services/SearchManager';
import logger from '../utils/logger';

export const createSearch = async (req: Request, res: Response) => {
  logger.info('Received request to create search', { body: req.body });

  try {
    const { keyword, location, refreshInterval } = req.body;
    const newSearch = await SearchDefinition.create({ keyword, location, refreshInterval });
    await scheduleJob(newSearch);
    res.status(201).json({ message: 'Search created', data: newSearch });
  } catch (error: any) {
    logger.error('Error creating search', { error: error.message });
    res.status(500).json({ error: error.message });
  }
};

export const getAllSearches = async (req: Request, res: Response) => {
  try {
    const searches = await SearchDefinition.findAll();
    res.status(200).json(searches);
  } catch (error: any) {
    logger.error('Error fetching searches', { error: error.message });
    res.status(500).json({ error: error.message });
  }
};

export const updateSearch = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { keyword, location, refreshInterval } = req.body;
    const search = await SearchDefinition.findByPk(id);

    if (!search) {
      logger.warn('Search not found', { id });
      return res.status(404).json({ error: 'Search not found' });
    }

    search.keyword = keyword || search.keyword;
    search.location = location || search.location;
    search.refreshInterval = refreshInterval || search.refreshInterval;
    await search.save();
    await scheduleJob(search);
    res.status(200).json(search);
  } catch (error: any) {
    logger.error('Error updating search', { error: error.message });
    res.status(500).json({ error: error.message });
  }
};

export const deleteSearch = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const search = await SearchDefinition.findByPk(id);

    if (!search) {
      logger.warn('Search not found', { id });
      return res.status(404).json({ error: 'Search not found' });
    }

    await search.destroy();
    res.status(200).json({ message: 'Search deleted' });
  } catch (error: any) {
    logger.error('Error deleting search', { error: error.message });
    res.status(500).json({ error: error.message });
  }
};

// ./server.ts

// ./server.ts

import express from 'express';
import bodyParser from 'body-parser';
import searchRoutes from './routes/SearchRoutes';
import sequelize from './db';
import SearchDefinition from './models/SearchDefinition';
import SearchResult from './models/SearchResult';
import { startMonitoringAllSearches } from './services/SearchManager';
import logger from './utils/logger';

sequelize.sync();

const app = express();
const port = process.env.PORT || 3000;

app.use(bodyParser.json());

app.use((req, res, next) => {
  logger.info(`Request received`, { method: req.method, path: req.path });
  next();
});

app.use('/api', searchRoutes);

app.listen(port, async () => {
  logger.info(`Server is running on port ${port}`);
  try {
    await sequelize.authenticate();
    await SearchDefinition.sync();
    await SearchResult.sync();
    await startMonitoringAllSearches();
    logger.info('Database connected and models synchronized');
  } catch (error) {
    logger.error('Error connecting to the database', { error: (error as Error).message });
  }
});

// ./db.ts

// src/db.ts

import { Sequelize } from 'sequelize';
import { dbConfig } from './config';

const sequelize = new Sequelize(dbConfig.database, dbConfig.username, dbConfig.password, {
  host: dbConfig.host,
  dialect: 'postgres',
});

export default sequelize;

// ./routes/SearchRoutes.ts

// src/routes/searchRoutes.ts

import { Router } from 'express';
import { getAllSearches, createSearch, updateSearch, deleteSearch } from '../controllers/SearchController';

const router = Router();

router.get('/searches', getAllSearches);
router.post('/searches', createSearch);
router.put('/searches/:id', updateSearch);
router.delete('/searches/:id', deleteSearch);

export default router;

// ./services/SearchManager.ts

// ./services/SearchManager.ts

import nodeSchedule from 'node-schedule';
import SearchDefinition from '../models/SearchDefinition';
import SearchResult from '../models/SearchResult';
import fetchJobListings from './LinkedInService';
import logger from '../utils/logger';

const jobs: { [key: number]: nodeSchedule.Job } = {};

export const scheduleJob = async (search: SearchDefinition) => {
  if (jobs[search.id]) {
    jobs[search.id].cancel();
  }

  logger.info('Scheduling job', { searchId: search.id, refreshInterval: search.refreshInterval });

  const job = nodeSchedule.scheduleJob(`*/${search.refreshInterval} * * * *`, async () => {
    try {
      const jobListings = await fetchJobListings({
        keyword: search.keyword,
        location: search.location,
      });

      for (const listing of jobListings) {
        await SearchResult.create({
          searchId: search.id,
          position: listing.position,
          company: listing.company,
          location: listing.location,
          date: listing.date,
          salary: listing.salary,
          jobUrl: listing.jobUrl,
        });
      }

      logger.info('Job listings fetched and saved', { searchId: search.id });
    } catch (error) {
      logger.error('Error during job execution', { error: (error as Error).message });
    }
  });

  jobs[search.id] = job;
};

export const startMonitoringAllSearches = async () => {
  try {
    const searches = await SearchDefinition.findAll();
    searches.forEach(scheduleJob);
    logger.info('Started monitoring all searches');
  } catch (error) {
    logger.error('Error starting monitoring of searches', { error: (error as Error).message });
  }
};

export const stopJob = (searchId: number) => {
  if (jobs[searchId]) {
    jobs[searchId].cancel();
    delete jobs[searchId];
    logger.info('Stopped job', { searchId });
  }
};

// ./services/LinkedInService.ts

// src/services/LinkedInService.ts

import { RestliClient } from 'linkedin-api-client';
import dotenv from 'dotenv';

dotenv.config();

const accessToken = process.env.ACCESS_TOKEN || process.env.LINKEDIN_ACCESS_TOKEN;

if (!accessToken) {
  throw new Error('Access token is not defined. Please check your environment variables.');
}

const restliClient = new RestliClient();

const fetchJobListings = async (queryObject: { keyword: string; location: string }) => {
  try {
    const response = await restliClient.get({
      resourcePath: `jobSearch?q=jobs&keywords=${encodeURIComponent(queryObject.keyword)}&location=${encodeURIComponent(queryObject.location)}`,
      accessToken: accessToken as string,
    });
    return response.data.elements;
  } catch (error) {
    console.error('Error fetching job listings:', error);
    return [];
  }
};

export default fetchJobListings;

